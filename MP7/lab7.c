/* lab7.c
 * Denzel Murdaugh                     <--- replace with your word!
 * Denzelm                             <--- replace with your user word!
 * ECE 223 Spring 2016
 * MP7
 *
 * NOTE:  You must update all of the following comments!
 *
 * Propose: 
 *
 * Assumptions: 
 *
 * An outline for the interactive menu input is provided.  Details need to be
 * completed but the format of the commands and the output generated by the
 * print statements must not be changed. You have to call the correct 
 * print statement in response to the input
 *
 * Bugs: Many details have not been implemented.
 *
 * See the ECE 223 programming guide
 *
 * Are you unhappy with the way this code is formatted?  You can easily
 * reformat (and automatically indent) your code using the astyle 
 * command.  If it is not installed use the Ubuntu Software Center to 
 * install astyle.  Then in a terminal on the command line do
 *     astyle --style=kr lab7.c
 *
 * See "man astyle" for different styles.  Replace "kr" with one of
 * ansi, java, gnu, linux, or google to see different options.  Or, set up 
 * your own style.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <ctype.h>
#include <limits.h>
#include <time.h>
#include <unistd.h>
#include "hash.h"

#define TRUE 1
#define FALSE 0

#define MAXLINE 128
#define word_SIZE 16
#define MIN_WORD_LEN 3
#define MAX_WORD_LEN 30

// prototypes
int find_first_prime(int number);

// constants used to indicate type of probing.
// This should probably be in your hash table header file and not here
//enum probe_dec_t {LINEAR, DOUBLE};

int main(int argc, char * argv[])
{
    int probe_dec = LINEAR;
    char line[MAXLINE];
    char command[MAXLINE];
    char first_arg[MAXLINE];
    char junk[MAXLINE];
    char wordin[MAXLINE];
    char docName[word_SIZE+1];
    char base_doc_word[word_SIZE+1];
    char doc_ascii_num[word_SIZE+1];
    int num_docs = -1;
    int num_words = 0;
    int num_items;
    int i = -1234567;
    clock_t start, end;
    FILE *fpt;
    
    
    if (argc != 3 && argc != 4) {
        fprintf(stderr, "Usage: ./lab7 <filename_base> <num_docs> {linear|double}\n");
        exit(1);
    }
    num_docs = atoi(argv[2]);
    if (num_docs < 1) {
        fprintf(stderr, "Invalid number docs %d from %s\n", num_docs, argv[2]);
        exit(2);
    } 
    if (strlen(argv[1]) < 3 || strlen(argv[1]) > word_SIZE) {
        fprintf(stderr, "Invalid base word for files %s\n", argv[1]);
        exit(2);
    }
    strcpy(base_doc_word, argv[1]);

    if (argc == 4) {
        if (strcmp(argv[3], "linear") == 0) {
            probe_dec = LINEAR;
            printf("Open addressing with linear probe sequence\n");
        } else if (strcmp(argv[3], "double") == 0) {
            probe_dec = DOUBLE;
            printf("Open addressing with double hashing\n");
        } else {
            fprintf(stderr, "invalid type of probing decrement: %s\n", argv[3]);
            fprintf(stderr, "must be {linear | double}\n");
            exit(1);
        }
    }
    
    printf("Lab7 Number of documents is %d. Possible commands:\n", num_docs);
    printf("  MAX word: the document that uses this word the largest number of times\n");
    printf("  MIN word: the document that uses this word the fewest number of times\n");
    printf("  DIST word: the distribution of the word in each document\n");
    printf("  UNIQUE x: number of words unique to document x\n");
    printf("  COUNT x: number of words found in document x\n");
    printf("  PRINT x: print each word and number of times used in doc x\n");
    printf("  PRINT: print table with words and count of times used\n");

    printf("QUIT\n");
    table_t *T=tableConstruct(17,probe_dec,num_docs);
    T->subHash = (T->size % 2 == 0) ? T->size / 2 : (T->size + 1) / 2;
    if(T->size<1)
    printf("error here 0\n");
    start = clock();
    // First phase: read all documents and build hash table
    // Use probe_dec to indicate the type of probing
    // Set the initial size of the hash table to 17
   
    // open file 
    int doc_number;
    for(doc_number = 0; doc_number < num_docs; doc_number++)
    {
        strcpy(docName, base_doc_word);
        sprintf(doc_ascii_num, "%d", doc_number);
        strcat(docName, doc_ascii_num);
        fpt = fopen(docName, "r");
        if (fpt == NULL) {
            fprintf(stderr, "Unable to open %s for reading\n", docName);
            fprintf(stderr, "Base filename %s for %d docs\n", base_doc_word, num_docs);
            exit(1);
        }
        if(T->size<1)
        printf("error here 2\n");
        // remember fgets includes newline \n unless line too long
        while (fgets(line, MAXLINE, fpt) != NULL) {
            int num_items = sscanf(line, "%s", wordin);
            if (num_items != 1)   // failed to read first word on line
                continue;
            int word_len = strlen(wordin);
            if (word_len < MIN_WORD_LEN || word_len > MAX_WORD_LEN) {
                fprintf(stderr, "Invalid input word (%s)\n", wordin);
                exit(1);
            }
            float load;
            // Add your code here to add wordin to hash table
            if(probe_dec==LINEAR){
                load=(float)T->num_keys/T->size;
                if (load > 0.75){
                    T=rehashTable(T);
                }
                insertInHash(T,Hash(wordin,strlen(wordin),T->size),wordin,doc_number);
            }    
            else{
                load=(float)T->num_keys/T->size;
                if (load > 0.75){
                    T=rehashTable(T);
                    T->subHash = T->size / 2;
                }
                insertIntoHashTable(T,Hash(wordin,strlen(wordin),T->size),wordin,doc_number);
            }
            num_words++;
        }
        fclose(fpt);
    }
    end = clock();
    printf("Read %d words from %d documents in %g msecs\n", num_words, 
            num_docs, 1000.0*(end-start)/CLOCKS_PER_SEC);
/***************************************/
//display(T); //for testing
/****************************************/
    // Second phase: gather input from user
    start = clock();
    // remember fgets includes newline \n unless line too long
    while (fgets(line, MAXLINE, stdin) != NULL) {
        num_items = sscanf(line, "%s %s %s", command, first_arg, junk);
        int count = -99;
        int which_doc = -999;
        int var;
        if (num_items == 2 && strcmp(command, "MAX") == 0) {
            if (strlen(first_arg) < MIN_WORD_LEN) {
                printf("Invalid word for MAX: %s\n", first_arg);
            } else {
            
                // add code to find count and which_doc 
                if(probe_dec==LINEAR){
                    var=searchElement(T,Hash(first_arg,strlen(first_arg),T->size));
                }
                else{
                    var=searchData(T,Hash(first_arg,strlen(first_arg),T->size));
                    if(var!=-1){
                        printf("found %s\n", T->entry[var].word);
                    }
                }
                if(var!=-1 && strcmp(T->entry[var].word,first_arg)==0){
                    for(i=0;i<T->num_docs;i++){
                        if(T->entry[var].doc_info[i]>count){
                           count=T->entry[var].doc_info[i];
                           which_doc=i;
                        }
                     }
                  printf("max found (%s) %d time%s in doc %d\n", 
                            first_arg, count, count>1?"s":"",which_doc);
                } else {
                    printf("max did not find (%s) in any doc\n", first_arg);
                }
            }
        } else if (num_items == 2 && strcmp(command, "MIN") == 0) {
            if (strlen(first_arg) < MIN_WORD_LEN) {
                printf("Invalid word for MIN: %s\n", first_arg);
            } else {

                // add code to find count and which_doc 
                if(probe_dec==LINEAR){
                    var=searchElement(T,Hash(first_arg,strlen(first_arg),T->size));
                }
                else
                    var=searchData(T,Hash(first_arg,strlen(first_arg),T->size));
                if(var!=-1 && strcmp(T->entry[var].word,first_arg)==0){
                    count=10000;
                    for(i=0;i<T->num_docs;i++){
                        if(T->entry[var].doc_info[i]<count && T->entry[var].doc_info[i]>0){
                           count=T->entry[var].doc_info[i];
                           which_doc=i;
                        }
                     }
                    printf("min Found (%s) %d time%s in doc %d\n", 
                            first_arg, count, count>1?"s":"", which_doc);
                } else {
                    printf("min did not find (%s) in any doc\n", first_arg);
                }
            }
        } else if (num_items == 2 && strcmp(command, "DIST") == 0) {
            if (strlen(first_arg) < MIN_WORD_LEN) {
                printf("Invalid word for DIST: %s\n", first_arg);
            } else {

                // add code to determine if word is found and if so 
                // how many times in each document 
                if(probe_dec==LINEAR){
                    var=searchElement(T,Hash(first_arg,strlen(first_arg),T->size));
                }
                else
                    var=searchData(T,Hash(first_arg,strlen(first_arg),T->size));
                // If the word is not found in any document 
                    if(var==-1){
                    printf("dist did not find (%s) in any doc\n", first_arg);
                }else{
                // else if found, how many times in each document
                    for(i=0;i<num_docs;i++){
                        if(T->entry[var].doc_info[i]!=0){
                            count=T->entry[var].doc_info[i];
                            which_doc=i;
                    printf("Used %s %d time%s in doc %d\n", 
                           first_arg, count, count>1?"s":" ", which_doc);
                        }
                    }
            }
           }
        } else if (num_items == 2 && strcmp(command, "UNIQUE") == 0) {
            doc_number = atoi(first_arg);
            if (doc_number < 0 || doc_number >= num_docs) {
                printf("Invalid document number: %d only %d docs\n", 
                        doc_number, num_docs);
            } else {
                int count=0;
                // add code to find count and a word at word_key
                char *word_key = malloc(30);
                int flag=1;
                int j;
                for(i=0;i<T->size;i++){
                    if(T->entry[i].marker!=1)
                        continue;
                    else{
                        for(j=0;j<num_docs;j++){
                            if(j!=doc_number){
                               if(T->entry[i].doc_info[j]>0){
                                flag=1;
                                break;
                                
                                }
                                else{
                                  flag=0; 
                                }
                            }
                        }
                        if(flag==0){
                        strcpy(word_key,T->entry[i].word);
                        count++;
                    }
                    }
                    
                }
                if (count>0) {
                    printf("Found %d unique word%s in doc %d\n", 
                            count, count>1?"s":"", doc_number);
                    printf("   A unique word is %s\n", word_key);
                } else {
                    printf("This document has no unique words %d\n", doc_number);
                }
                free(word_key);
            }
        } else if (num_items == 2 && strcmp(command, "COUNT") == 0) {
            doc_number = atoi(first_arg);
            if (doc_number < 0 || doc_number >= num_docs) {
                printf("Invalid document number: %d only %d docs\n", 
                        doc_number, num_docs);
            } else {

                // add code to find count and words used most and least 
                int min_word_count = INT_MAX;
                int max_word_count = -1;
                char *min_word_key =malloc(30), *max_word_key =malloc(30);
                count=0;
                for(i=0;i<T->size;i++){
                    if(T->entry[i].doc_info[doc_number]>0){
                        if(T->entry[i].doc_info[doc_number]<min_word_count){
                        min_word_count=T->entry[i].doc_info[doc_number];
                        strcpy(min_word_key,T->entry[i].word);
                        }
                        if(T->entry[i].doc_info[doc_number]>max_word_count){
                        max_word_count=T->entry[i].doc_info[doc_number];
                        strcpy(max_word_key,T->entry[i].word);
                        }
                        count++;
                    }
               }
  
                        

                printf("Found %d word%s in doc %d\n", 
                        count, count>1?"s":"", doc_number);
                printf("   %s used most times %d\n", max_word_key, max_word_count);
                printf("   %s used fewest times %d\n", min_word_key, min_word_count);
                free(max_word_key);
            free(min_word_key);
            }
            
        } else if (num_items == 1 && strcmp(command, "PRINT") == 0) {
            // print the hash table
            display(T);
        } else if (num_items == 2 && strcmp(command, "PRINT") == 0) {
            doc_number = atoi(first_arg);
            if (doc_number < 0 || doc_number >= num_docs) {
                printf("Invalid document number: %d only %d docs\n", 
                        doc_number, num_docs);
            } else {
                // add code to find word and count
                for(i=0;i<T->size;i++){
                    if(T->entry[i].doc_info[doc_number]>0){
                        printf("%d: %s %d\n", i, T->entry[i].word, T->entry[i].doc_info[doc_number]);
                    }
                }
            }
        } else if (num_items == 1 && strcmp(command, "STATS") == 0) {
            int tableSize = T->size;
            int entries = T->num_keys;
            float loadFactor = (float) entries / tableSize;
            printf("Table size (%d), load factor (%g)\n", tableSize, loadFactor);
        } else if (num_items == 1 && strcmp(command, "QUIT") == 0) {
            freeHash(T);
            break;
        } else {
            printf("# %s", line);
        }
    }
    end = clock();
    printf("Processed commands in %g msecs\n",
            1000.0*(end-start)/CLOCKS_PER_SEC);
    exit(0);
}

/* return first prime number at number or greater
 *
 * There is at least one prime p such that n <= p < 2n
 * for n>=25, n <= p < 1.2n
 */
int find_first_prime(int number)
{
    int i, foundfactor;
    double upper;
    assert(number > 1);
    // if even move to next odd
    if (number % 2 == 0)
        number++;
    do {
        foundfactor = 0;      // assume number is prime
        upper = sqrt(number);
        for (i = 3; i < upper + 1; i += 2)
            if (number % i == 0) {
                foundfactor = 1;
                number += 2;  // only test odds
                break;
            }
    } while (foundfactor);
    return number;
}
/* commands specified to vim. ts: tabstop, sts: soft tabstop sw: shiftwidth */
/* vi:set ts=8 sts=4 sw=4 et: */
