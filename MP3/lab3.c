/* lab3.c
 * Denzel Murdaugh                        <--- replace with your name!
 * Denzelm                              <--- replace with your user name!
 * ECE 223 Spring 2016
 * MP3
 *
 * NOTE:  You must update all of the following comments!
 *
 * Propose: A template for MP2 
 *
 * Assumptions: This file is simple.  Input is collected and the
 * appropriate wifi function is called.
 *
 * An outline for the interactive menu input is provided.  Details need to be
 * completed but format of the commands and the output generated by the
 * print statements must not be changed. You have to call the corrent 
 * print statement in response to the input
 *
 * Bugs: Many details have not been implemented.
 *
 * See the ECE 223 programming guide
 *
 * Are you unhappy with the way this code is formatted?  You can easily
 * reformat (and automatically indent) your code using the astyle 
 * command.  If it is not installed use the Ubuntu Software Center to 
 * install astyle.  Then in a terminal on the command line do
 *     astyle --style=kr lab2.c
 *
 * See "man astyle" for different styles.  Replace "kr" with one of
 * ansi, java, gnu, linux, or google to see different options.  Or, set up 
 * your own style.
 *
 * To create a nicely formated PDF file for printing install the enscript 
 * command.  To create a PDF for "file.c" in landscape with 2 columns do:
 *     enscript file.c -G2rE -o - | ps2pdf - file.pdf
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include "datatypes.h"
#include "list.h"
#include "trte_support.h"

int main(int argc, char * argv[])
{
    list_t * sorted_list;
    list_t * unsorted_list;
    char line[MAXLINE];
    char command[MAXLINE];
    char junk[MAXLINE];
    int listsize = -1;
    int num_items;
    int input_src_ip, input_dest_ip;
    //int count=0;

    if (argc != 2) {
        printf("Usage: ./lab3 list_size\n");
        exit(1);
    }
    listsize = atoi(argv[1]);
    if (listsize < 1) {
        printf("Invalid list size %d\n", listsize);
        exit(2);
    } 
    //printf("Lab3 list size is %d. Possible commands:\n", listsize);
    //printf("Sorted list: INSERT; FIND s or FIND s d; REMOVE s or REMOVE s d; PRINT; REVERSE\n");

    //printf("Queue      : ADDTAIL; RMHEAD; PRINTHEAD; PRINTQ\n");
    //printf("           : STATS; QUIT\n");

    // Create two List objects
    /* this list is sorted */
    sorted_list = trte_create();

    /* this list is unsorted and has no duplicates */
    unsorted_list = trte_create();

    /* remember fgets includes newline \n unless line too long */
    while (fgets(line, MAXLINE, stdin) != NULL) {
        num_items = sscanf(line, "%s %d %d %s", command, &input_src_ip, &input_dest_ip, junk);
        if (num_items == 1 && strcmp(command, "INSERT") == 0) {
            trte_add(sorted_list, listsize);
        } else if (num_items == 2 && strcmp(command, "FIND") == 0) {
            trte_find_first(sorted_list, input_src_ip);
        } else if (num_items == 3 && strcmp(command, "FIND") == 0) {
            trte_find(sorted_list, input_src_ip, input_dest_ip);
        } else if (num_items == 2 && strcmp(command, "REMOVE") == 0) {
            trte_remove_first(sorted_list, input_src_ip);
        } else if (num_items == 3 && strcmp(command, "REMOVE") == 0) {
            trte_remove(sorted_list, input_src_ip, input_dest_ip);
        } else if (num_items == 1 && strcmp(command, "REVERSE") == 0) {
            trte_reverse(sorted_list);
        } else if (num_items == 1 && strcmp(command, "PRINT") == 0) {
            trte_print(sorted_list, "List");
        } else if (num_items == 1 && strcmp(command, "ADDTAIL") == 0) {
            trte_add_tail(unsorted_list);
        } else if (num_items == 1 && strcmp(command, "RMHEAD") == 0) {
            trte_remove_head(unsorted_list);
        } else if (num_items == 1 && strcmp(command, "PRINTHEAD") == 0) {
            trte_find_head(unsorted_list);
        } else if (num_items == 1 && strcmp(command, "PRINTQ") == 0) {
            trte_print(unsorted_list, "Queue");
        } else if (num_items == 1 && strcmp(command, "STATS") == 0) {
            trte_stats(sorted_list, unsorted_list);
        } else if (num_items == 3 && strcmp(command, "SORT") == 0) {
            clock_t start, end;
            double elapse_time; /* time in milliseconds */
            int initialsize = list_size(unsorted_list);
            start = clock();
            list_sort(unsorted_list, input_src_ip, input_dest_ip);
            end = clock();
            elapse_time = 1000.0 * ((double) (end - start)) / CLOCKS_PER_SEC;
            assert(list_size(unsorted_list) == initialsize);
            printf("%d\t%f\t%d\t%d\n", initialsize, elapse_time, input_src_ip, input_dest_ip);
        } else if (num_items == 3 && strcmp(command, "ADDTAIL") == 0){
            trte_add_tail2(unsorted_list,input_src_ip,input_dest_ip);
        } else if (num_items == 1 && strcmp(command, "QUIT") == 0) {
            trte_cleanup(sorted_list);
            trte_cleanup(unsorted_list);
            //printf("Goodbye\n");
            break;
        } else {
            printf("# %s", line);
        }
    }
    exit(0);
}
/* commands specified to vim. ts: tabstop, sts: soft tabstop sw: shiftwidth */
/* vi:set ts=8 sts=4 sw=4 et: */
